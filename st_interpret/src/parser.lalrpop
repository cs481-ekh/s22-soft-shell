use std::str::FromStr;
use std::boxed::Box;
use std::vec::Vec;
use std::collections::HashMap;
use crate::ast::{VariableValue, VarsDec, VariableKind, Assignment, Program};

grammar;

// TODO change varible label to somthing specific to program name conventions
pub Program: Program = {
    r"(?i)PROGRAM" <vl:VariableLabel> <v:VarList> <s:StatementList> r"(?i)END_PROGRAM" => Program::Prog(vl, Some(v), s),
    r"(?i)PROGRAM" <vl:VariableLabel> <s:StatementList> r"(?i)END_PROGRAM" => Program::Prog(vl, None, s)
};

// Start of StatementList branch
StatementList: Vec<Assignment> = {
    <s:Statement> ";" => {let mut v = Vec::new(); v.push(<>); v},
    <s:Statement> ";" <mut sl:StatementList> => {sl.push(s); sl}
};

//TODO, type needs to be changed to something more general, also in statement list
Statement: Assignment = {
    <a:AssignmentStatement> => a
};

AssignmentStatement: Assignment = {
    <v:VariableLabel> ":=" <e:Expression> => Assignment::Asgn(<>)
};

// TODO expression not implimented fully, simply a basic type atm
Expression: VariableValue = {
    <c:Constant> => c
};

// TODO: add all types, this stores a litteral value, reusing variabletype enum
Constant: VariableValue = {
    <ui:Int> => VariableValue::INT(<>),
    <b:Bool> => VariableValue::BOOL(<>),
    <f:Real> => VariableValue::REAL(<>),
};



// Start of VarList branch
VarList: Vec<Box<VarsDec>> = {
    <vdt:VarsDec> => {let mut v = Vec::new(); v.push(<>); v},
    <vdt:VarsDec> <mut vl:VarList> => {vl.push(vdt); vl}
};

VarsDec: Box<VarsDec> = {
    <vk:VariableKind> <dl:DeclarationList> r"(?i)END_VAR"=> Box::new(VarsDec::DecList(<>))
};

DeclarationList: Box<HashMap<Box<String>, VariableValue>> = {
    <vl:VariableLabel> ":" <vt:VariableValue> ";" => {let mut m = HashMap::new(); m.insert(<>); Box::new(m)},
    <vl:VariableLabel> ":" <vt:VariableValue> ";" <mut dl:DeclarationList> => {dl.insert(vl, vt); dl}
};

//TODO: Add rest of varaible kinds
VariableKind: VariableKind = {
    r"(?i)VAR" => VariableKind::NORMAL,
};

//TODO: check if types are case sensitive
//TODO: add all var types
//TODO: Check if types have default value or not, change enum if they are unintallized, default values provided are hack
VariableValue: VariableValue = {
    r"(?i)bool" => VariableValue::BOOL(false),
    r"(?i)int" => VariableValue::INT(0),
    r"(?i)real" => VariableValue::REAL(0.0)
};

//TODO: include ST variable naming rules
VariableLabel: Box<String> = <s:VAR_NAME> => Box::new(s.to_string());

Int: i16 = <s:r"[0-9]+"> => i16::from_str(s).unwrap();
Bool: bool = <s:r"((?i)true|false)"> => bool::from_str(&s.to_lowercase()).unwrap();
Real: f32 = <s:r"\d*\.\d*"> => f32::from_str(s).unwrap();

// Sets regex precedence between terminals
match {
    r"(?i)int",
    r"(?i)bool",
    r"(?i)real",
    "(",
    ")",
    r"(?i)PROGRAM",
    r"(?i)END_PROGRAM",
    r"(?i)END_VAR",
    r"(?i)VAR",
    ":", // Type delcaration operator
    ";", // Statement end
    ":=", // Assignment operator
    r"[0-9]+", // int
    r"((?i)true|false)", // bool
    r"\d*\.\d*", // real
    
    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"\(\*([^*]|[\r\n]|(\*+([^*\)]|[\r\n])))*\*+\)" => { }, // `/* comment */`
} else {
    r"\w+" => VAR_NAME,
}
