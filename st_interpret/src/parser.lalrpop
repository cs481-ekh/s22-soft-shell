use std::str::FromStr;
use std::boxed::Box;
use std::vec::Vec;
use std::collections::HashMap;
use crate::ast::*;

grammar;

// TODO change varible label to somthing specific to program name conventions
pub Program: Program = {
    r"(?i)PROGRAM" <vl:VariableLabel> <v:VarList> <s:StatementList> r"(?i)END_PROGRAM" => Program::Prog(vl, Some(v), s),
    r"(?i)PROGRAM" <vl:VariableLabel> <s:StatementList> r"(?i)END_PROGRAM" => Program::Prog(vl, None, s)
};

// Start of StatementList branch
StatementList: Vec<Assignment> = {
    <s:Statement> ";" => {let mut v = Vec::new(); v.push(<>); v},
    <s:Statement> ";" <mut sl:StatementList> => {sl.push(s); sl}
};

//TODO, type needs to be changed to something more general, also in statement list
Statement: Assignment = {
    <a:AssignmentStatement> => a
};

AssignmentStatement: Assignment = {
    <v:VariableLabel> ":=" <e:Expression> => Assignment::Asgn(<>)
};


// Start of expression branch
Expression: Expression = {
    <x:XOR_Expression> r"(?i)OR" <x2:XOR_Expression> => Expression::Expr(x, Some(x2)),
    <x:XOR_Expression> => Expression::Expr(x, None),
};

XOR_Expression: XOR_Expression = {
    <a:AND_Expression>  r"(?i)XOR" <a2:AND_Expression> => XOR_Expression::Xor(a, Some(a2)),
    <a:AND_Expression> => XOR_Expression::Xor(a, None),
};

AND_Expression: AND_Expression = {
  <c:Comparison> r"&|(?i)AND" <c2:Comparison> => AND_Expression::And(c, Some(c2)),
  <c:Comparison> => AND_Expression::And(c, None),
};

Comparison: Comparison = {
    <e:EquExpression> "=" <e2:EquExpression> => Comparison::Comp_Eq(e, Some((true, e2))),
    <e:EquExpression> "<>" <e2:EquExpression> => Comparison::Comp_Eq(e, Some((false, e2))),
    <e:EquExpression> => Comparison::Comp_Eq(e, None),
};

EquExpression: EquExpression = {
    <a:AddExpression> <c:ComparisionOperator> <a2:AddExpression> => EquExpression::Equ(a, Some((c, a2))),
    <a:AddExpression> => EquExpression::Equ(a, None),
};

AddExpression: AddExpression = {
    <t:Term> <a:AddOperator> <t2:Term> => AddExpression::Add(t, Some((a, t2))),
    <t:Term> => AddExpression::Add(t, None),
};

Term: Term = {
    <p:PowerExpression> <m:MultiplyOperator> <p2:PowerExpression> => Term::Term(p, Some((m, p2))),
    <p:PowerExpression> => Term::Term(p, None),
};

PowerExpression: PowerExpression = {
    <u:UnaryExpression> "**" <u2:UnaryExpression> => PowerExpression::Power(u, Some(u2)),
    <u:UnaryExpression> => PowerExpression::Power(u, None),
};

UnaryExpression: UnaryExpression = {
    <u:UnaryOperator> <p:PrimaryExpression> => UnaryExpression::Unary(p, Some(u)),
    <p:PrimaryExpression> => UnaryExpression::Unary(p, None),
};

PrimaryExpression: PrimaryExpression = {
    <c:Constant> => PrimaryExpression::Const(<>),
    <v:VariableLabel> => PrimaryExpression::VarName(<>),
    "(" <e:Expression> ")" => PrimaryExpression::Expr(Box::new(<>)),
};

// TODO: add all types, this stores a litteral value, reusing variabletype enum
Constant: VariableValue = {
    <ui:Int> => VariableValue::INT(<>),
    <b:Bool> => VariableValue::BOOL(<>),
    <f:Real> => VariableValue::REAL(<>),
};

// Expression operators
ComparisionOperator: ComparisonOperator = {
    "<" => ComparisonOperator::LESS_THAN,
    ">" => ComparisonOperator::GREATER_THAN,
    "<=" => ComparisonOperator::LESS_EQUAL_THAN,
    ">=" => ComparisonOperator::GREATER_EQUAL_THAN,
};

AddOperator: AddOperator = {
    "+" => AddOperator::ADD,
    "-" => AddOperator::SUBTRACT,
};

MultiplyOperator: MultiplyOperator = {
    "*" => MultiplyOperator::MULTIPLY,
    "/" => MultiplyOperator::DIVIDE,
    r"(?i)MOD" => MultiplyOperator::MODULO,
};

UnaryOperator: UnaryOperator = {
    "-" => UnaryOperator::NEGATIVE,
    r"(?i)NOT" => UnaryOperator::NOT,
};
// end expression operators
// end of expression branch


// Start of VarList branch
VarList: Vec<Box<VarsDec>> = {
    <vdt:VarsDec> => {let mut v = Vec::new(); v.push(<>); v},
    <vdt:VarsDec> <mut vl:VarList> => {vl.push(vdt); vl}
};

VarsDec: Box<VarsDec> = {
    <vk:VariableKind> <dl:DeclarationList> r"(?i)END_VAR"=> Box::new(VarsDec::DecList(<>))
};

DeclarationList: Box<HashMap<Box<String>, VariableValue>> = {
    <vl:VariableLabel> ":" <vt:VariableValue> ";" => {let mut m = HashMap::new(); m.insert(<>); Box::new(m)},
    <vl:VariableLabel> ":" <vt:VariableValue> ";" <mut dl:DeclarationList> => {dl.insert(vl, vt); dl}
};

//TODO: Add rest of varaible kinds
VariableKind: VariableKind = {
    r"(?i)VAR" => VariableKind::NORMAL,
};

//TODO: check if types are case sensitive
//TODO: add all var types
//TODO: Check if types have default value or not, change enum if they are unintallized, default values provided are hack
VariableValue: VariableValue = {
    r"(?i)bool" => VariableValue::BOOL(false),
    r"(?i)int" => VariableValue::INT(0),
    r"(?i)real" => VariableValue::REAL(0.0)
};

//TODO: include ST variable naming rules
VariableLabel: Box<String> = <s:VAR_NAME> => Box::new(s.to_string());

Int: i16 = <s:r"[0-9]+"> => i16::from_str(s).unwrap();
Bool: bool = <s:r"((?i)true|false)"> => bool::from_str(&s.to_lowercase()).unwrap();
Real: f32 = <s:r"\d*\.\d*"> => f32::from_str(s).unwrap();

// Sets regex precedence between terminals
match {
    r"(?i)int",
    r"(?i)bool",
    r"(?i)real",
    "(",
    ")",
    r"(?i)PROGRAM",
    r"(?i)END_PROGRAM",
    r"(?i)END_VAR",
    r"(?i)VAR",
    ":", // Type delcaration operator
    ";", // Statement end
    ":=", // Assignment operator
    "<", // Less than operator
    ">", // Greater than operator
    "<=", // Less than or equal to operator
    ">=", // Greater than or equal to operator
    "+", // Addition operator
    "-", // Subtraction operator
    "*", // Multiplication operator
    "/", // Division operator
    "**", // Power operator
    r"(?i)MOD", // Modulo operator
    r"(?i)NOT", // Not unary operator
    "=", // Equality operator
    "<>", // Not equal operator
    r"&|(?i)AND", // And operator
    r"(?i)XOR", // Xor operator
    r"(?i)OR", // Or operator
    r"[0-9]+", // int
    r"((?i)true|false)", // bool
    r"\d*\.\d*", // real
    
    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"\(\*([^*]|[\r\n]|(\*+([^*\)]|[\r\n])))*\*+\)" => { }, // `/* comment */`
} else {
    r"\w+" => VAR_NAME,
}
